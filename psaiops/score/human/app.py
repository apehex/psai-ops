import copy
import functools

import gradio
import numpy
import torch
import torch.cuda
import matplotlib.pyplot

import psaiops.common.model
import psaiops.common.style
import psaiops.common.tokenizer
import psaiops.score.surprisal.lib

# META #########################################################################

MODEL = 'openai/gpt-oss-20b'

TITLE = '''Human Score'''
INTRO = '''Leverages an open source LLM as critic to take apart the sections written by a human from the text generated by an AI.\nThe final probability score is a combination of several metrics computed token by token.\nThe accuracy of the scores increases with the prompt length and the size of the window.\n\nSee the tab "docs" for more informations, in particular the formulas of the computations.'''
DOCS = '''The model used as critic is `openai/gpt-oss-20b`.'''

# ENUMS ########################################################################

# metric types
TOKENS = 1
CRITIC = 2

# COLORS #######################################################################

def create_selection_cmap() -> dict:
    return {
        '0': '#000000',
        '1': '#004444',
        '2': '#444400',
        '3': '#440044',}

def create_score_cmap() -> dict:
    return {str(__i): '#{:02x}0000'.format(int(2.55 * __i)) for __i in range(101)}

# INTRO ########################################################################

def create_text_block(text: str) -> dict:
    __text = gradio.Markdown(text, line_breaks=True)
    return {'text_block': __text}

# MODEL ########################################################################

def create_model_block() -> dict:
    __model = gradio.Dropdown(label='Model', value='openai/gpt-oss-20b', choices=['openai/gpt-oss-20b'], scale=1, allow_custom_value=False, multiselect=False, interactive=True) # 'openai/gpt-oss-120b'
    return {'model_block': __model,}

# SAMPLING #####################################################################

def create_sampling_block() -> dict:
    __tokens = gradio.Slider(label='Tokens', value=32, minimum=1, maximum=256, step=1, scale=1, interactive=True)
    __topk = gradio.Slider(label='Top K', value=16, minimum=1, maximum=2048, step=1, scale=1, interactive=True)
    __topp = gradio.Slider(label='Top P', value=0.9, minimum=0.0, maximum=1.0, step=0.01, scale=1, interactive=True)
    return {
        'tokens_block': __tokens,
        'topk_block': __topk,
        'topp_block': __topp,}

# INPUTS #######################################################################

def create_inputs_block(label: str='Prompt') -> dict:
    __input = gradio.Textbox(label=label, value='', placeholder='A string of tokens to score.', lines=4, scale=1, interactive=True)
    return {'input_block': __input}

# PLOTS ########################################################################

def create_plot_block(label: str='Plot', prefix: str='') -> dict:
    __plot = gradio.Plot(label=label, scale=1)
    return {prefix + 'plot_block': __plot,}

# HIGHLIGHT ####################################################################

def create_highlight_block(label: str='Score', prefix: str='', cmap: dict=create_selection_cmap()) -> dict:
    __highlight = gradio.HighlightedText(label=label, value='', scale=1, interactive=False, show_legend=False, show_inline_category=False, combine_adjacent=False, color_map=cmap, elem_classes='white-text')
    return {prefix + 'highlight_block': __highlight}

# REDUCTION ####################################################################

def create_metrics_block(label: str='Metrics', prefix: str='') -> dict:
    __metrics = gradio.CheckboxGroup(label=label, type='value', value=[CRITIC, TOKENS], choices=[('Critic', CRITIC), ('Tokens', TOKENS)], interactive=True)
    return {prefix + 'metric_block': __metrics,}

def create_window_block(label: str='Window', prefix: str='') -> dict:
    __window = gradio.Slider(label=label, value=5, minimum=1, maximum=32, step=1, scale=1, interactive=True)
    return {prefix + 'window_block': __window,}

# ACTIONS ######################################################################

def create_actions_block() -> dict:
    __process = gradio.Button('Score', variant='primary', size='lg', scale=1, interactive=True)
    return {'process_block': __process,}

# STATE ########################################################################

def create_state() -> dict:
    return {
        'output_state': gradio.State(None),
        'hidden_state': gradio.State(None),}

# LAYOUT #######################################################################

def create_layout(intro: str=INTRO, docs: str=DOCS) -> dict:
    __fields = {}
    __fields.update(create_text_block(text=intro))
    with gradio.Tabs():
        with gradio.Tab('Main') as __main_tab:
            __fields.update({'main_tab': __main_tab})
            with gradio.Row(equal_height=True):
                __fields.update(create_inputs_block())
            with gradio.Row(equal_height=True):
                __fields.update(create_highlight_block(label='Score', prefix='final_', cmap=create_score_cmap()))
            with gradio.Row(equal_height=True):
                __fields.update(create_metrics_block(label='Metrics', prefix='final_'))
                __fields.update(create_window_block(label='Window', prefix='final_'))
            with gradio.Row(equal_height=True):
                __fields.update(create_actions_block())
        with gradio.Tab('Plots') as __plots_tab:
            __fields.update({'plots_tab': __plots_tab})
            with gradio.Row(equal_height=True):
                __fields.update(create_plot_block(label='Log Rank By Position', prefix='rank_'))
        with gradio.Tab('Settings') as __settings_tab:
            __fields.update({'settings_tab': __settings_tab})
            with gradio.Row(equal_height=True):
                __fields.update(create_model_block())
            with gradio.Row(equal_height=True):
                __fields.update(create_sampling_block())
        with gradio.Tab('Docs') as __docs_tab:
            __fields.update({'docs_tab': __docs_tab})
            __fields.update(create_text_block(text=docs))
    return __fields

# TOKENS #######################################################################

# WINDOW #######################################################################

def update_window_range(
    current_val: float,
    output_arr: object,
) -> dict:
    # exit if some values are missing
    if (current_val is None) or (output_arr is None) or (len(output_arr) == 0):
        return gradio.update()
    # take the generated tokens into account
    __max = max(1, int(output_arr.shape[-1]))
    # keep the previous value if possible
    __val = min(int(current_val), __max)
    # return a gradio update dictionary
    return gradio.update(value=__val, maximum=__max)

# APP ##########################################################################

def create_app(
    title: str=TITLE,
    intro: str=INTRO
) -> gradio.Blocks:
    __fields = {}
    with gradio.Blocks(title=title) as __app:
        # create the UI
        __fields.update(create_layout(intro=intro))
        # init the state
        __fields.update(create_state())
        # update the data after clicking process
        __fields['process_block'].click()
        # update the range of possible values for the window
        __fields['output_state'].change(
            fn=update_window_range,
            inputs=[__fields[__k] for __k in ['final_window_block', 'output_state']],
            outputs=__fields['final_window_block'],
            queue=False,
            show_progress='hidden')
        # gradio application
        return __app

# MAIN #########################################################################

if __name__ == '__main__':
    # load the model
    __device = 'cuda' if torch.cuda.is_available() else 'cpu'
    __tokenizer = psaiops.common.tokenizer.get_tokenizer(name=MODEL, device=__device)
    # __model = psaiops.common.model.get_model(name=MODEL, device=__device)
    # __norm = copy.deepcopy(__model.model.norm).cpu()
    # __head = copy.deepcopy(__model.lm_head).cpu()
    # adapt the event handlers
    # the event handlers are created outside so that they can be wrapped with `spaces.GPU` if necessary
    __app = create_app()
    __app.launch(theme=gradio.themes.Soft(), css=psaiops.common.style.BUTTON, share=True, debug=True)
